 Spring Framework 및 SpringBoot3


 1. Spring Framework

  1) 개요

   - Road Johnson 이 'Export One-on-One J2EE Development without EJB(Enterprise Java Beans)' 책을 통해서 소개. 
   - 2003년 2월부터 오픈 소스로 시작된 프로젝트.

  2) 특징
   - 경량의 컴포넌트.
   - IoC ( Inversion of Control: 제어의 역행) 컨테이너(스프링의 특정 클래스) 기반에서 관리됨.
     ( Serlvet/JSP가 tomcat 컨테이너에서 관리된것과 유사 )
     IoC 개념? 클래스를 직접 생성하지 않고 의존성도 직접 설정하지 않음. 모두 Spring에게 맡김.

   - JDBC 추상화 ( Mybatis 처럼 wrap한 클래스들 제공 ==> 예외처리 불필요 ... )
   - 선언적 트랜잭션 ( 어노테이션으로 트랜잭션 처리 가능 ==> @Transactional 지정. 모두 성공하면 자동으로 commit,
                                               만약 하나라도 실패(RuntimeException)하면 모두 자동으로 rollback 됨.
      예>
        @Service
	//@Transactional
        public class MemberServiceImple {

          @Transactional
          public int delAndUpdate(){

              session.delete(~~~~);
	      session.update(~~~~);
              ...
	  }


   - 다양한 뷰(html화면) 기술 ( JSP, Thymeleaf(boot에서 권장), velocity 등 )
   - 검증된 Spring MVC 아키텍쳐 제공.
   - REST API 지원. ( 클라이언트와 서버간에 JSON 데이터 포맷으로 통신하는 방법의미)

      예>  클라이언트                         서버(웹서버)
          ---------                      ------
	  PC용 웹브라우저       JSON
	  모바일,테블릿   <---------------->
	  OTT 셋탑박스
	  자동차,,,
	  ..

                     
  3) Spring Framework 생태계
     
     https://spring.io

     - Spring Framework
     - Spring Boot
     - Spring Security
     - Spring Data
     - Spring AI
       ...

  4) Spring Framework 버전

    https://spring.io/projects/spring-framework#learn

    - 6.X ( 2022년 )
      JDK 17+

  5) 용어 정리
   
   가. POJO ( Plain Old Java Object)
     - 일반적인 오래된 자바 객체라는 의미.
     - 어떠한 클래스 또는 인터페이스를 상속 및 구현하지 않아서
       어떤 개발환경에서도 사용가능한 특징을 가짐.
         예>

        
	HttpServlet
	    |
	    |
	 MyServlet ( MyServlet 는 웹어플리케이션 환경에서만 사용 가능한 제약이 됨 )

   나. Java Beans
      - EJB 에서 사용했던 용어
      - 특정한 규칙을 가짐
        a. public 기본 생성자만 존재
	b. getter/setter 메서드 존재
	c. implments Serialzable

   다. Spring bean
      - POJO 기반의 Spring 어플리케이션에서 만든 모든 자바 클래스 의미.

  
   라. IoC ( Inversion of Control : 제어의 역행 )
      - 우리가 필요한 빈(클래스)를 직접 생성하거나 빈간에 의존성을 직접 설정하지 않고
        우리대신에 외부(IoC Container)에서 필요한 빈을 생성 및 의존성을 설정하는 개념.

                   
   마. IoC Container

      - IoC 방법으로 빈(클래스)를 관리한다는 의미에서 IoC Container 라고 부름.
        (Spring Container, Spring Context 모두 동일한 개념이다. )

      - 하드웨어 개념이 들어갔으나  일반 클래스이다.  ( XXXApplicationContext )


      * 계층 구조


 BeanFactory(인터페이스) MessageSource(인터페이스)
	        |
                |
	    ApplicationContext ( 인터페이스, org.springframework.context )

	         |
		 |
            AnnotationConfigApplicationContext(클래스, Java SE 환경의 IoC Container 임)
	    GenericXmlApplicationContext(클래스, Java SE 환경의 IoC Container 임)
	    ..

	    XXXWebApplicationContext(클래스, Java EE 환경의 IoC Container 임)

  

   바. 의존성 주입 ( Dependency Injection: DI )
  
      - 개념: 임의의 클래스에서 다른 클래스를 참조할 때
            직접 생성하는 것이 아니고 외부에서 생성한후 생성자 또는 setter 메서드 이용해서 
	    설정하는 방법 의미함.

      - 종류 2가지

        a. 생성자 주입 ( Constructor-based Dependency Injection )
	b. setter 메서드 주입 ( setter-based Dependency Injection )

     예>

         BoardListServlet     BoardService                              BoardDAO
	                       
			        @AutoWired
			        BoardDAO dao;

				//setter 메서드
			       public void setDao(BoardDAO dao){
			         this.dao =dao;
			       }
			       // 생성자 
			       public BoardService(BoardDAO dao){
			         this.dao =dao;
			       }
	
	BoardService service =
	   new BoardServiceImpl(new BoardDAO());  // 생성자 주입
	//service.setDao(new BoardDAO());         //  setter 메서드 주입


2. 환경 설정

  1) JDK 17 설치
  2) SpringBoot 3.2.8 ( Spring Framework 6.X 내장됨 )
    => SpringBoot 3 버전은 JDK 17+ 필요함.
  
  3) 개발툴 설치
    - STS ( Spring Tool Suite ) 툴 지원.
    - 현재 지원되는 종류 2가지

      sts3 : Spring Framework 와 Spring Boot를 각각 개발할 수 있는 개발툴.


      sts4 : Spring Boot 만 지원되는 개발툴.
     

    - 한글 인코딩 확인
       
        window > preference > general > workspace 에서 UTF-8 확인

    - JSP/CSS/jS 위한 web 플러그인 추가

       hep > eclipse marketplace >  web 검색 > Eclipse Enterprise Java and  Web Developer Tool 3.36 설치

  
  4) tomcat 설치 안함.
     이유는 SpringBoot에서는 내장 tomcat 을 사용한다.


 3.  SpringBoot 프로젝트 작성

   1) 로컬로 프로젝트 작성

     STS > File > NEW > Spring Starter Project (Boot 용 프로젝트 )

   2) 웹사이트 이용 ( initializer 방법 )

    http://start.spring.io 

    project: maven 선택




 4. 빌드툴(build tool)

   - 개발할 때 도움을 받을 수 있는 툴.

   - 전통적인 프로그램 개발 프로세스 ( 수동으로 설정 )


   소스작성--->필요한jar다운로드 및 컴파일 ---> 단위테스트 ---> 패키징(jar, war) -----> 배포

    
                    
           <----------------------------------------------------------->
	     자동화 가능

    - 종류 2가지

     1) maven
       - 설정정보를 pom.xml 파일에 설정
       - 빌드 과정 단계
         a. validate
	 b. compile
	 c. test
	 d. package
	 e. install ( 패키징, jar 압축 )  clean (퍄키징 삭제)
	 f. deploy

     
     2) gradle
       - 설정정보를 build.gradle 파일에 설정


    - 필요한 의존성을 설정하는 방법
      
      http://mvnrepository.com 에서 필요한 키워드 입력하고  maven 또는 gradle 항목에서 복사해서 사용함.


5.  maven 빌드툴의 기본 디렉터리 구조

     src/main/java
      ==> *.java 가 저장
      ==> 패키지 지정

     src/main/resources
     ==> *.java 제외한 나머지 파일들
         빌드할때 maven이 src/main/resources 파일들을  src/main/java로 자동으로 복사한다.
       ( 예> jdbc.properties, Configuration.xml, Mapper.xml 등 )

     src/test/java
      ==> 단위테스트용 *.java 저장

     src/test/resources
      ==> 단위테스트용 *.java가 필요한 파일들


     JRE System library ( JDK 17 라이브러리 )
     Maven Dependency
     ==> pom.xml에 등록된 의존성 파일들(*.jar)이 저장
     ==> 기본 저장 디렉터리는 C:\Users\ssginc73\.m2\repository 이다.
         가끔식 네트워크 이슈로 다운로드가 안 될수 있음.
	 해결은 강사 및 같은 조원들에게 요청 ( repository.zip )

     pom.xml ( Project Object Model )
      - 전반적인 설정정보 저장.
       예> 버전, 의존성파일(dependency),....
      - 계층구조로 되어있음 ( 부모에 해당되는 pom.xml 이 존재함 )


6.  Application 파일

  - src/main/java 에 저장되어 있고 반드시 필요한 코드임. ( 웹 어플리케이션을 개발할때도 필요함 )
  - 프로그램 시작점(starting point) 역할.

	@SpringBootApplication
	public class Application {

		public static void main(String[] args) {
			SpringApplication.run(DemoApplication.class, args);
			
		}
	}

  - SpringBoot 웹 어플리케이션 개발시 배포는 jar로도 가능하다. 이유는  main 메서드를 가지고 있기 때문이다.
    (일반적으로 비웹은 jar로 배포하고 웹은 war로 배포함)

  
  - @SpringBootApplication 의 3가지 기능
  https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html


     a. @EnableAutoConfiguration : pom.xml에 <dependency>태그로 등록된 라이브러리를 보고, 그에 알맞은 최적의 설정정보를 자동으로 설정해줌.
                                  예> spring-boot-starter-web 지정하면 자동으로 웹어프리케이션 개발 위한 설정들이 자동으로 셋팅됨.
     b. @ComponentScan : 자동으로 빈(클래스)를 찾아서 new 해줌.
                         단, Application.java 가 가진 패키지의 서브패키지로 만들어야 됨.
     c. @SpringBootConfiguration : 자동으로 추가되는 설정 이외의 개발자가 필요시 추가적인 Configuration 설정이 가능함.


7. Spring Boot의 추가적인 설정 정보 방법

    src/main/resource/application.properties 에 설정 ( application.yml 야물)

    예> DB연동시 필요시 4가지 정보,
       tomcat의 port 번호,
       ...
       ..

#########################################################################################################

8. 로깅 (logging) 처리

  1)개념
   - 어플리케이션을 개발할 때 문제가 발생되면 대부분 콘솔(console) 정보를 보고 문제를 해결.
     콘솔에 출력되는 정보를 로그(log) 라고 부름.

   - 필요시 로그 출력은 이전에는 System.out.println으로 해결했으나 앞으로는 전문적인 로그 관리 라이브러리를 사용해야 된다.

   - 대표적인 로그 관리 라이브러리
     a. log4j ( 구현체 )
     b. logback (구현체, Spring Boot 기본 로그임 )

   - SLF4j 
    ==> 인터페이스로서 Log4j와 Logback 구현체들이 SLF4j 인터페이스를 implments해서 만들어짐.
        따라서 실제로 SLFj4 사용하면 Log4j에서 logback으로 변경시 코드를 수정할 필요가 없다.

  - 로그 레벨 5가지

      trace
      debug
      info (기본)
      warn
      error

   동작방식은 지정된 레벨 및 하위까지 포함해서 로그가 출력됨.

  - 구현 방법

    가. Logger 생성
  
       // Logging의 인터페이스 기능인 slf4j 사용.
       import org.slf4j.Logger;
       import org.slf4j.LoggerFactory;

       Logger logger = LoggerFactory.getLogger(클래스명.class);	 

    나. 로그레벨에 해당되는 메서드 호출

       logger.trace(값);
       logger.debug(값);
       logger.info(값); // 기본
       logger.warn(값);
       logger.error(값);

    다. application.propeties에서 로그레벨 변경
     
       문법:  logging.level.패키지=로그레벨

       logging.level.root=warn  # 전체 패키지 로그 설정
       #logging.level.org.springframework=info  # org.springframework 패키지믄 info로 커스터마이징
	logging.level.com.exam=warn             # com.exam 패키지믄 warn 로 커스터마이징

	logging.file.name=c:\\Temp\\app.log     # 파일로 로그 저장.

#########################################################################

9. 빈 ( 클래스) 생성

  - 직접 new 하지 않음.
  - 권장하는 방법은 권장패키지 구조를 이용하는 것이다.
   https://docs.spring.io/spring-boot/reference/using/structuring-your-code.html

  - 자동생성 빈 생성 방법- 2 step

    step1: 권장패키지 구조로 만듬.
           @SpringBootApplication 가진 Application.java의 패키지의 서브 패키지로 만듬.

    step2: 자동으로 생성할 빈을 어노테이션으로 지정해야됨.
           - @Component  <== 범용적으로 사용
	   - @Service    <== ServiceImpl 역할 ( 비즈니스로직 처리 및 트랜잭션 처리 )	
	   - @Repository <== DAO 역할 ( DB 연동 )
	   - @Controller <== 서블릿 역할
	     @RestController
	   - @Configuration <== 설정 정보를 추가할 때 ( application.properties 대신에 ) 
  

    * 웹 어플리케이션 아키텍쳐                                          @Transactional
                                    @Controller                @Service                 @Repository      
                      1)                              2)                      3)                     4)
     웹브라우저(다른툴)-----------------> Controller 작성 <-----------> Service 작성 <----------> Repository <----> DB
                                                      7)                       6)             5)JDBC,MyBatis,JPA
					 |
					 |   8) 리다이렉트/포워드
					 |
		<-----------------   뷰화면(JSP,Thymeleaf) : View
                     9




 

10. 의존성 주입 1 ( dependency injection : DI )
 
   1) 개념
     특정 A클래스에서 다른 B 클래스를 참조할 때 A클래스에서 B의 참조변수가 필요하다.
     이때 B 클래스를 외부에서 생성해서 A 클래스에게 전달할 수 있다.

     예>
        A ----------------> B
      
      B b;


   2) 방법 2가지

    가. 생성자 이용 (권장)

     예>
			  DeptService
	Application <---> DeptServiceImpl  <------------------> DeptDAO
	  main()
                                           <------------------> UserDAO

                         public DeptServiceImpl(DeptDAO dao,UserDAO dao2){}

                  
    나. @Autowired 어노테이션 이용

     		          DeptService
	Application <---> DeptServiceImpl  <------------------> DeptDAO
	  main()                           
	                                    <------------------> UserDAO
                          @Autowired 
                          DeptDAO deptDAO;

			  @Autowired 
                          UserDAO userDAO;



11. 빈 접근하는 방법.

   @SpringBootApplication
public class Application implements CommandLineRunner{

	@Autowired
	ApplicationContext ctx; // AnnotationConfigApplicationContext 의존성주입됨
	
	//1. Logger 얻기
	private Logger logger = LoggerFactory.getLogger(getClass());
	
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);		
	}

	@Override
	public void run(String... args) throws Exception {
		logger.info("Application: {} ", ctx);
		
		// 빈참조
		DeptServiceImpl service = ctx.getBean("xxx", DeptServiceImpl.class);
		List<String> list = service.list();
		logger.info("List: {} ", list);
		
	}


12. 의존성 주입 2 ( dependency injection : DI )

   1)개념
   기본적으로 생성자 주입 또는 @Autowired는  동일한 타입을 주입을 시킴.
   따라서 동일한 타입이 한개면 그것이 주입되고 
   만약에 동일한 타입이 여러개면 어떤 클래스를 주입할지 모르기 때문에 에러가 발생됨.
   따라서 명시적으로 주입할 클래스를 알려줘야 된다. 이때 @Qualifier("빈이름") 사용한다.

  예>
			  DeptService                            CommonDAO (인터페이스)
	Application <---> DeptServiceImpl  <------------------>  DeptDAO
	  main()                                                 UserDAO

	                  @Autowired
			  @Qualifier("dept")
			   CommonDAO dao;
	
			   또는
	
			  CommonDAO dao;

			  public DeptServiceImpl(@Qualifier("빈이름")  CommonDAO dao){
			   this.dao = dao;
			  }

13.  빈의 scope
https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#page-title

   1) 개념
      ApplicationContext에서 생성된 빈(클래스)는 싱글톤(singleton)으로 관리된다.
      즉 단 한번만 생성됨. 
      따라서 bean을 요청하면 항상 동일한 인스턴스(100번지)를 반환하게 된다.

   2) scope 값 종류

     singleton : 기본, 단 한번만 생성됨. 따라서 bean을 요청하면 항상 동일한 인스턴스(100번지)를 반환하게 된다.
                 여러 사용자가 공유가 가능 ( thread-unsafe )
     
     prototype : bean을 요청하면 매번 새롭게 생성해서 반환.
                 여러 사용자가 공유 불가 ( thread-safe)

     request : web 환경,  HttpServletRequest scope와 동일

     session : web 환경,  HttpSession scope와 동일

     application : web 환경,  ServletContext scope와 동일

   
   3) scope 값 변경
https://docs.spring.io/spring-boot/docs/3.2.12/reference/pdf/spring-boot-reference.pdf

     - @Scope 이용

     - 문법:

        @Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON) <== @Scope("singleton")
	@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE) <== @Scope("prototype")
	..

   
14. 빈의 초기화 작업 및 cleanup 작업 (***************)

   - 서블릿의 lifecycle과 비슷한 개념 ( 예> init()과 destroy() )
   - 구현
     
      @PostConstruct
      public void start(){
         //초기화
      }	
	
      @PreDestroy
      public void shutdown(){
        // cleanup
      
      }	

 
15. profile

 1) 개념
  - 개발할 때 다양한 환경을 구축해서 개발함

  예> dev 환경(개발환경), Q/A 환경,  prod 환경(배포환경)


    //개발환경 (dev)

    Application <---------> DeptServiceImpl <---------> H2DAO  <----> MySQL(MariaDB) (경량 DB)


     //배포환경 (prod)

    Application <---------> DeptServiceImpl <---------> MySQLDAO  <----> AWS(RDS)

  
 2) 구현방법 1 -  프로파일에 따른 properties 선택하는 방법

   각 환경에 맞는 application.properties 작성하자.

    - application.properties ( 기본 )
      ==> spring.profiles.active=prod

    - 문법: application-프로파일명.properties
     예> application-dev.properties
         ==> MySQL 연동설정 정보

        application-prod.properties
	==> AWS 연동설정 정보

 2) 구현방법 2 -  프로파일에 따른 빈 선택하는 방법


   예>     
	@Repository
	@Profile("prod")
	public class MySQLDAO {



	@Repository
	@Profile("dev")
	public class H2DAO {



16. AOP ( Aspect Oriented Programming : 관점 지향 프로그래밍 )

  1) 개념

   // 현재코드
                            
   웹브라우저 <---------------> Controller <---------> Service <-------------> DAO <--------> mysql
                           - 핵심코드              - 핵심코드                - 핵심코드
			   - 부수코드(로깅)          - 부수코드(로깅)            - 부수코드(로깅)
 
	
	핵심코드: 로그인, 회원가입, 장바구니, ......

	부수코드: 예외처리, 로깅, 보안, 트랜잭션처리,....

 
    결론은 혼합(핵심+부수)된 코드를 핵심코드와 부수코드를 분리해서  부수코드가 필요한 레이어에서 주입받아서 사용하도록 하자.


     웹브라우저 <---------------> Servlet <---------> Service <-------------> DAO <--------> mysql
                           - 핵심코드              - 핵심코드                - 핵심코드
			   

			     부수코드구현클래스
			      -부수코드(로깅)

  2) AOP 기술

    가. AspectJ
      - AOP 원천기술 ( 1995년 )
      - 다양한 주입시점이 있음
      예> 핵심코드를 가진 Servlet의 특정 메서드 호출할 때,
         핵심코드를 가진 Servlet의 변수값이 변경될 때,
         핵심코드를 가진 Servlet이 객체생성 될 때,
	 ...



    나. Spring AOP
      - 원천기술인 AspectJ에서 일부분만 빌려서 사용함.
        따라서 pom.xml에 <dependency> 필요.
      - 단 하나의 주입시점만 가짐. ( 핵심코드를 가진 Servlet의 특정 메서드 호출(************)할 때)


 3) 용어정리

   가. aspect : 부가기능 구현 클래스
   나. joinpoint :  target object 와 aspect가 만나는 시점 의미.
                   원천기술인 AspectJ는 다양한 시점이 있으나 Spring AOP에서는 메서드 호출 시점이다.
   다. pointcut  :  target object 의 어떤 메서드를 호출했을 때 join할 지 표현식을 의미함. 예> list()

   라. advice    : target object 의 
                  메서드 호출전 ( before advice )
		  메서드 호출후 ( after advice ) 
		  메서드 호출해서 성공시 ( after returning advice )
                  메서드 호출해서 에러발생시 ( after throwing advice ) 
	          메서드 호출전,호출후,성공시,에러발생시 모두 포함하는 경우 ( around advice)
   마. weaving   : 조인(주입) 의미
   바. target object : 핵심 클래스 의미



     // 핵심클래스                                         // 부가기능 구현 클래스

    public class DeptServiceImpl{                      public class LogPrintAspect{
							 
							  public void print(){
							     logger.info(...);
							  }
        // 핵심기능: 목록보기
        public List<String> list(){                     }
           ....
	    
	}

	public int insert(){                     }
           ....
	    
	}

    }

  4) 실습
   
   가.  의존성 설정
	<!-- AOP 설정-->
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	<!-- AOP 설정-->


   나. target object ( 핵심기능 클래스 )
       @Service("deptService")
	public class DeptServiceImpl implements DeptService{

		@Override
		public String sayEcho() {
			return "안녕하세요";
		}

		@Override
		public List<String> list() {
			return Arrays.asList("홍길동","이순신");
		}

	}

   다. aspect ( 부가기능 클래스 )

      @Component
	@Aspect
	public class LoggingAspect {

		public void loggingPrint() {
			 //로그처리 담당
		}
		
	}

   라. pointcut 지정

     - target object 의 어떤 메서드를 호출했을 때 join할 지 표현식을 의미함.
     https://docs.spring.io/spring-framework/reference/6.1/core/aop/ataspectj/pointcuts.html#aop-pointcuts-examples


     a. execution()
        - 메서드를 지정할 때 사용
	예> 
	@Pointcut("execution(public String sayEcho())")
      
     b. bean()
        - 컴포넌트(빈)의 이름 지정
	예> @Pointcut("bean(service)")  
	  
	   @Service("service")
	   public class BoardServiceImple ~{}

     c. within()
        - 빈의 타입이나 패키지 지정

	예> @Pointcut("within(com.exam.*)")

     d. combine ( && , ||, ! )

      예> @Pointcut("execution(public String sayEcho()) ||  bean(service) ")

 
   마. advice 지정

      - target object 의 
                  메서드 호출전 ( before advice, @Before )
		  메서드 호출후 ( after advice , @After ) 
		  메서드 호출해서 리턴값을 리턴하고 성공시 ( after returning advice, @AfterReturning )
                  메서드 호출해서 에러발생시 ( after throwing advice, @AfterThrowing ) 
	          메서드 호출전,호출후,성공시,에러발생시 모두 포함하는 경우 ( around advice, @Around)

      // advice + pointcut 같이 표현
	고("execution(public String say2*())")
	public void loggingPrint1() {
		 //로그처리 담당
		logger.info("LOGGER:{}", "@Before 어드바이스1" );
	}
	
	// advice와 pointcut 분리
	@Pointcut("execution(public String sayEcho2())")
	public void businessService() {}
	
	@Before("businessService()")
	public void loggingPrint2() {
		 //로그처리 담당
		logger.info("LOGGER:{}", "@Before 어드바이스2" );
	}
	
	@Before("businessService()")
	public void loggingPrint3(JoinPoint point) {
		 //로그처리 담당
//		logger.info("LOGGER:{},{}", "@Before 어드바이스3", point.getSignature() );
		logger.info("LOGGER:{},{}", "@Before 어드바이스3", point.getSignature().getName() );
	}


17. MyBatis + MySQL 연동 방법1

 1) 2개의 jar 필요
   - mybatis.jar
   - mysql-connector.jar

   SpringBoot에서는 pom.xml 에 <dependency> 태그에 설정.
   https://mvnrepository.com/  참조
   https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#requirements
   https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#maven

        <!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter -->
	<dependency>
	    <groupId>org.mybatis.spring.boot</groupId>
	    <artifactId>mybatis-spring-boot-starter</artifactId>
	    <version>3.0.3</version>
	</dependency>
        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
	<dependency>
	    <groupId>mysql</groupId>
	    <artifactId>mysql-connector-java</artifactId>
	    <version>8.0.33</version>
	</dependency>


 2) DB 연동 4가지 정보 필요
   - 이전에는 jdbc.properties 에서 설정했는데
    SpringBoot 에서는 application.properties에서 설정함.

	# 이전 jdbc.properties 설정
	jdbc.driver=com.mysql.cj.jdbc.Driver
	jdbc.url=jdbc:mysql://localhost:3306/testdb
	jdbc.userid=root
	jdbc.passwd=1234
  

  # application.properties
  https://docs.spring.io/spring-boot/docs/3.2.12/reference/html/data.html#data.sql.datasource.configuration
  # DB 연동
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql://localhost:3306/testdb
	spring.datasource.username=root
	spring.datasource.password=1234


  3) DTO 작성 및 별칭

    - com.exam.dto.DeptDTO 작성
    
	@Alias("DeptDTO")
	public class DeptDTO {

  4) 이전 Configuration.xml 필요없음.
     ( jdbc.properties 등록
       4가지정보 이용 ${driver} 설정

       DTO 별칭 등록
       Mapper.xml 등록 )

    대신 application.properties 담당한다.

  5) DeptMapper.xml 작성

     com/exam/config/DeptMapper.xml


   6)  DTO 별칭 등록 및  Mapper.xml 등록
  
     # DeptMapper 등록
	mybatis.mapper-locations=com/exam/config/*Mapper.xml

	# DTO 별칭
	mybatis.type-aliases-package=com.exam.dto

################################################################################


    7) java 파일 작성

                                    DeptService                     
				    @Service                         @Repository
    Application.java  <--------->  DeptServiceImpl <---------------> DeptDAO <-----------> MySQL
    main()


    8) 이전 MySqlSessionFactory.java 필요없음.
       ( Configuration.xml 읽어서 SqlSessionFactory 반환하고 
         최종적으로 Service클래스에서 SqlSession  얻고 DAO클래스에서 전달해서 사용함.
	 Service클래스에서 SqlSession 얻은 이유는 트랜잭션 처리하기 위해서이다.
	 commit()/rollback() 직접 호출하는 방식임.
	 )


       SpringBoot에서는 SqlSession 역할의 SqlSessionTemplate 사용한다.
       그리고  Service클래스 대신에 DAO에서 SqlSessionTemplate 을 직접 얻어서 사용한다.
       이유는 commit()/rollback() 직접 호출하는 방법의 트랜잭션 처리가 아니기 때문이다.
       선언적 트랜잭션 방식을 사용한다. (@Transactional 이용)

        @Transactional 클래스 레벨 및 메서드 레벨 사용 가능.
	==> @Target(value={TYPE, METHOD})

    ########################################################
      * 트랜잭션 처리 ( Service 클래스에서 처리 )
	(1) Java SE ( JDBC, auto commit )

	    public void tx(){
	      Connection con = ~;
            try{
	con.setAutoCommit(false);
	        int n = dao.insert(~);
		int n2 = dato.delete(~);
	con.commit();
            }catch(Exception e){
        con.rollback();
	    }


        (2) Java SE/EE ( MyBatis, auto commit 아님 )

            public void tx(){

	     SqlSession session = MySqlSesssionFactory.getSession();
	     try{
                 int n = dao.insert(~);
		 int n2 = dato.delete(~);
                 session.commit();
	     }catch(Exception e){
	         session.rollback();
	     }finally{
                session.close();
	       
          
	 (3) Spring Framework/ SpringBoot ( auto commit )

	      @Transactional  // 성공하면 모두 자동으로 commit 되고 하나라도 실패하면 모두 자동으로 rollback 됨
              public void tx(){
	        
		 int n = dao.insert(~);
		 int n2 = dato.delete(~);
		
	      }


    ########################################################       
    9) DAO 작업
    
      - SqlSession 역할의 SqlSessionTemplate 주입 받음.

        @Repository
	public class DeptDAO {

		SqlSessionTemplate session;

		public DeptDAO(SqlSessionTemplate session) {
			this.session = session;
		}
	


17. MyBatis + MySQL 연동 방법2

   - DAO 대신에 @Mapper 어노테이션을 가진 인터페이스 이용.

   1) DAO 삭제
   2) DeptMapper.xml 과 자동 연동하는 인터페이스 작성
      
     - DeptMapper.java 작성
     - 반드시 DeptMapper.java의 패키지와 
       DeptMapper.xml의 namespace와 동일해야 된다.

     - DeptMapper.java 구현은 다음과 같다.

       id값과 일치하는 메서드를 지정함.
       parameterType과 일치하는 파라미터타입을 지정함.
       resultType과 일치하는 리턴타입을 지정함.
      
     - @Mapper 지정.

    
    3) Service 작업
     
      - DAO 대신에 DeptMapper 주입받음.

###########################################################
18. 개발용 데이터 초기화
https://docs.spring.io/spring-boot/docs/3.2.12/reference/html/howto.html#howto.data-initialization

   1) 개념
     실제 DB에 만들어진 테이블 및 데이터를 사용하지 않고
     개발중에 동적으로 테이블 생성 및 데이터도 저장할 수 있는 방법이다.

   2) 구현 방법

    가. schema.sql 와 data.sql 작성
     src/main/resource 에  schema.sql 와 data.sql 작성.

     프로젝트를 실행할때마다 매번 생성된다.

    나. application.properties 에서 데이터 초기화 활성화

     # 데이터 초기화 활성
      spring.sql.init.mode=always  # never


###########################################################

19. Spring MVC

  1) 서블릿/JSP 의 MVC 아키텍쳐

   요청URL: http://localhost:8090/컨텍스트명/서블릿맵핑
     
     예> http://localhost:8090/app/test

            요청
   웹브라우저 ----------> 서블릿    <------------------> 서비스 <-----------> DAO <-------> MySQL
                     -개발자가 생성
		     -서블릿맵핑(/test) @WebServlet
		     -중요작업 2가지
		       a. 로직처리후 서비스 연동
		          (사용자입력데이터 얻기 예> request.getParameter("key")
                           세션처리  예> HttpSession session =request.getSession();
                                     조건체크후 session.setAttribute("dto", dto);
				     ..
                       b. jsp 선택
		         - forward
			 - redirect
         <-------------
	    응답

    - JSP가 기본적으로 지원됨.


    ///////////////////////////////////
      예>
    
   Tomcat(8080)
       Blog프로젝트(물리적인프로젝트)  - /blog (컨텍스트명(context), 논리적인 이름)
	 ..
	 ..
         com.servlet.AdminServlet

	       doGet(){}

       요청URL(OLD): http://localhost:8080/blog/servlet/com.servlet.AdminServlet <== 보안이슈 + 길다

        서블릿맵핑(serlvet mapping): web.xml 또는 @WebServlet("/admin")
  
        요청URL(NEW): http://localhost:8080/blog/admin    <== 보안이슈 해결 + 짧다

       Shop프로젝트            - /shop (컨텍스트명(context),논리적인 이름)
	 ..
	 ..
         com.servlet.TestServlet

	       doGet(){}

 
      요청URL(OLD): http://localhost:8080/shop/servlet/com.servlet.TestServlet 

    ///////////////////////////////////


  2) SpringMVC 의 아키텍쳐

   요청URL: http://localhost:8090/컨텍스트명/서블릿맵핑/요청맵핑값 (**************)
     
     예> http://localhost:8090/app/list
        http://localhost:8090/app/write
        http://localhost:8090/app/delete
  
                                                 @RestController
           요청                                    @Controller     @Service         @Repository       
  웹브라우저 ------------> DispatcherServlet서블릿 <---> Controller <---> 서비스 <-----------> DAO <-------> MySQL
                      - 제공됨.                     -중요작업 2가지
		      - 서블릿맵핑(/)                a. 로직처리후 서비스 연동
		                                 b. jsp 선택

						  @RequestMapping("/list")
						  public String aaa(){
						     //게시판 목록보기
						  }
						  @RequestMapping("/write")
						  public String bbb(int n){
						     //게시판 글쓰기	
						  }
						  @RequestMapping("/delete")
						  public void ccc(HttpServletRequest request){
						     //게시판 글삭제	
						  }

     - Spring Boot는 JSP가 기본적으로 지원 안됨. 따라서 JSP 사용하기 위해서는 의존성 추가 및 웹 디렉터리도 명시적으로 생성해야 된다.
       Spring Boot는 JSP(*.jsp) 보다 Thymeleaf(*.html) 지원.


 ///////////////////////////////////////////
  * Sping MVC 아키텍쳐
                                                             @RestController
   웹브라우저 --     -------------> 서블릿(자동으로제공)                @Controller
                                DispatcherServlet ---------> Controller                   -->Service-->Repository-->DB
				서블릿맵핑: /			//요청맵핑값(request mapppong)
							     @GetMapping("/signup")
						              public void signup(){}
							     @GetMapping("/login")
							      public void login(){}
							      ...
						 
						   <--------
						     데이터 ( 뷰에서 보여줄 데이터: 모델 )
						     와
					 	     뷰(JSP|Thymeleaf,..)

	<----------------------    JSP

   요청URL(NEW): http://localhost:8080/컨텍스트명/서블릿맵핑/요청맵핑값
               http://localhost:8080/컨텍스트명/

     예>
          http://localhost:8080/컨텍스트명/signup
	  http://localhost:8080/컨텍스트명/login

  
  * 사용자 입력 폼 데이터가 서버에 전달되는 포맷

    GET 방식:   URL에 query string( name=value&name=value ) 형식으로 전달됨.
       
            예> http://localhost:8090/app/login?userid=aaa&passwd=1234

    POST 방식:  URL 이용하지 body 에 포함되어 전달됨.

            예> http://localhost:8090/app/login

             body: userid=aaa&passwd=1234

	     멱등이 지원안되기 때문에 post로 요청하고 새로고침하면 명시적으로 재요청했는지를 경고창으로 물어봄.



 //////////////////////////////////////////////



  3) Spring MVC 구현 순서


    가. 웹 어플리케이션 개발 위한 의존성 추가

      		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

     ==> 웹개발 위한 JAR 및 Tomcat 설치됨 ( 내장 tomcat )
     ==> tomcat 의 기본 port는 8080
        변경 가능하고 application.properties 에서 server.port=8090 설정한다.
          # context명 변경
          server.servlet.context-path=/app 설정한다. 



     ==> 만약 404 면  WhiteLabel Error page 보여준다.
       이것은 내부적으로 SpringBoot가 404 페이지를 만들어서 제공함.
       spring-boot-autoconfigure-3.2.8.jar
       > org.springframework.boot.autoconfigure.web.servlet.error
       > ErrorMvcAutoConfiguration.class 클릭 > 213 라인에 html 제공됨.


    나. Controller 작성

       - POJO 기반이고 @Controller 또는 @RestController 지정.

       - 각 기능에 해당되는 메서드 작성하고 @RequestMapping("/요청매핑값") 설정한다.
         이렇게 설정하면 요청 URL 다음과 같다.

	  요청 URL: http://localhost:8090/컨텍스트명/서블릿맵핑명/요청맵핑명  (***********)

          기본 컨텍스트명: ''
	  서블릿맵핑명:   /

        - 컨텍스트명 변경 가능하고 application.properties 에서 
	  # context명 변경
          server.servlet.context-path=/app 설정한다.
	  
    
    다. JSP 설정

      
      a. JSP/CSS/jS 위한 web 플러그인 추가

       hep > eclipse marketplace >  web 검색 > Eclipse Enterprise Java and  Web Developer Tool 3.36 설치

      
      b. JSP 의존성 추가
        - SpringBoot는 JSP 지원안됨.

        <dependency>
	  <groupId>org.apache.tomcat.embed</groupId>
	  <artifactId>tomcat-embed-jasper</artifactId>
	  <scope>provided</scope>
	</dependency>
	<dependency>
	  <groupId>jakarta.servlet.jsp.jstl</groupId>
	  <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
	</dependency>
	<dependency>
	  <groupId>org.glassfish.web</groupId>
	  <artifactId>jakarta.servlet.jsp.jstl</artifactId>
	</dependency>


     c. 웹 디렉터리 명시적으로 생성 방법 2가지


       (1) src/main/resources 에 만드는 방법 ( 권장 )
        src/main/resources
             /META-INF/resources/WEB-INF/views/sayHello.jsp

       (2) src/main 에 만드는 방법
        src/main/webapps/WEB-INF/views/sayHello.jsp
	  


      ==> jsp가 WEB-INF에 저장된다. 따라서 웹 브라우저에서 직접 jsp를 접근할 수 없다.
          jsp 접근은 Controller 통해서 forward 또는 redirect로 접근이 가능하다.





      d. JSP 알려주기

        - Controller 에서 구현된 메서드 리턴값으로 알려준다.

	예>
	@RequestMapping("/list")
	public String aaa() {
		logger.info("LOGGER:{}", "aaa 호출");
		//return "/WEB-INF/views/sayHello.jsp";  // 문제점: 경로가 길다. 다른 view기술(thymeleaf)변경시 코드를 수정해야됨.
		return "sayHello";  // 나중에 prefix와 suffix가 자동으로 설정됨.
	}

       - Controller 의 메서드에서 String 타입을 리턴하면 String에는 JSP 정보가 담긴다. (***********)

       - /WEB-INF/views/sayHello.jsp  full 경로 지정할 때의 문제점 해결방법은 다음과 같다.
	application.properties에  prefix 와 suffix 설정한다.
	
	 # JSP용 prefix 와 suffix 설정
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp


       - Controller에서 JSP 요청은 forward로 처리됨. 따라서 URL 변경이 안됨.
        즉 Controller에서 request scope에 데이터를 저장하면 JSP에서 사용할 수 있다.

  ######################################################################
     * VSC의 Live Server 처럼 소스코드 변경시 바로 서버에 반영이 가능한 방법
       - devtools 의존성 추가

         <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
	 </dependency>




    ######################################################################
  
      라. 정적 파일 ( CSS, JS, image )
https://docs.spring.io/spring-boot/docs/3.2.12/reference/html/web.html#web.servlet.spring-mvc.static-content

     설정방법:
       src/main/resources
                    static 폴더
		      js 폴더
		        -*.js
		      css 폴더
		        _ *.css
		
		      images 폴더
		        - *.jpg
			  ..
		      
     접근방법:
       <head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<link rel="stylesheet" href="css/test.css">
	<script src="js/test.js"></script>
	</head>
	<body>
	 <h1>sayHello.jsp</h1>
	  <p>안녕하세요</p>
	  <img src="images/bottom1.gif" width="100" height="100" >
	</body>



20. @RequestMapping 정리

    1) 용도

    - 요청 URL에서 (http://localhost:8090/컨텍스트명/서블릿맵핑명/요청맵핑명  ) 사용하는 요청맵핑명을 
      @RequestMapping("/요청맵핑명")에 설정해서 요청에 대한 실제 처리를 위한 메서드를 선택하는 용도이다.

    2) 다양한 패턴이 제공됨. ( 메서드 레벨 )

       @RequestMapping("/list")
       @RequestMapping(value="/list")
       @RequestMapping(value={"/list", "/select"})
       @RequestMapping(value="/board/list")
       @RequestMapping(value="/member/list")
      @RequestMapping(value="/list*")  // /list , /listA, /listB ,..
      @RequestMapping(value="/list/*") // /list/xxx, /list/bbb, .. <== * 는 하나의 디렉터리 의미
      @RequestMapping(value="/list/*/some") // /list/xxx/some, /list/bbb/some, ..

      @RequestMapping(value="/list/**") // /list/xxx/yyy, /list/bbb, ..  <== ** 는 여러개의 디렉터리 의미


      // 다음코드는 에러발생 해결방법은 다음과 같다.
      https://docs.spring.io/spring-boot/docs/3.2.12/reference/html/web.html#web.servlet.spring-mvc.content-negotiation
      spring.mvc.pathmatch.matching-strategy=ant-path-matcher
      
      @RequestMapping(value="/list/**/some") // /list/xxx/some, /list/bbb/ccc/some, ..


    3) 클래스 레벨
 
      - 클래스 레벨의 요청값과 메서드 레벨의 요청값이 결합되어 최종적으로 요청맵핑값이 정해짐.

       예>
        @Controller
	@RequestMapping("/member")
	public class MemberController {

	private Logger logger = LoggerFactory.getLogger(getClass());
	
	
	@RequestMapping("/list")
	public String list() {
		logger.info("LOGGER:{}", "/member/list 호출");
		return "sayHello";
	}

	최종 요청매핍값: /member/list

      4) GET 및 POST 요청1 - 기본

         // 요청맵핑값과 method 가 모두 다른 경우1
	@RequestMapping(value = "/req/get", method = RequestMethod.GET )
	public String req_get() {
		logger.info("LOGGER:{}", "GET");
		return "main";
	}
	
	@RequestMapping(value = "/req/post", method = RequestMethod.POST )
	public String req_post() {
		logger.info("LOGGER:{}", "POST");
		return "main";
	}
	
       4) GET 및 POST 요청2 - method만 다른 경우

         예> 게시판 글쓰기

	   //가. 글쓰기 화면보기 ( GET 방식 )

      @RequestMapping(value = "/write", method = RequestMethod.GET )
	public String writeUI() {

		return "write";
	}
		
	   //나. 글쓰기       ( POST 방식 )

      @RequestMapping(value = "/write", method = RequestMethod.POST )
	public String write() {

		return "~~~";
	}

       4) GET 및 POST 요청3 ( 권장 )

         - @RequestMapping 문법 이후에 지원
  
           @RequestMapping(value = "/write", method = RequestMethod.GET )

	  ==> @GetMapping("/write")

	   @RequestMapping(value = "/write", method = RequestMethod.POST )

          ==> @PostMapping("/write")


21. Controller의 요청 처리 작업

   1. 사용자입력 데이터 얻기

    1) 이전 서블릿 처리
     
       public void doGet(HttpServletRequest request, HttpServletResponse response){

           String userid = request.getParameter("userid");
           String [] hobbies = request.getParameterValues("hobby");
 
           String userid2 = request.getParameter("userid2");  // null

	  String age = request.getParameter("age");
	  int age2 = Integer.parseInt(age);

    2) Spring Controller  처리

       - @RequestParam("/태그name값") 사용.
         태그name값에 해당되는 파라미터는 필수(required)임. 따라서 일치하는 태그name값이 없으면 에러가 발생됨.
	 옵션으로 변경가능하면 null 반환.( required=false )
	 null 값 대신에 초기화값 사용 가능. ( defaultValue = "초기값")

       - 전달되는 값이 정수이면 Controller 메서드에서 직접 Long(Integer) 타입의 정수로 저장 가능하다.

    
   2. 요청 헤더값 보기

          1) 이전 서블릿 처리
	      public void doGet(HttpServletRequest request, HttpServletResponse response){
		 
		  Enumeration<String> enu = request.getHeaderNames();
		 while(enu.hasMoreElements()) {
			 String key = enu.nextElement();
			 String value = request.getHeader(key);
			 
			 logger.info("LOGGER:{}={}", key, value);
		 }
		   
          2) Spring Controller  처리
              - @RequestHeader() 이용
               
		@GetMapping("/main")
		public String list(@RequestHeader("user-agent") String s,
					   @RequestHeader("accept-language") String s2) {
		
			 logger.info("LOGGER:user-agent={}", s);
			 logger.info("LOGGER:accept-language={}", s2);  // ko-KR,ko
			return "main";
		}

              - 나중에 다국어처리(I18N) 처리할 때 accept-language 헤더값을 사용하게 된다.



   3. 요청 쿠키값 보기

         1) 이전 서블릿 처리
            // 서블릿 쿠키 코드
	@GetMapping("/set")
	public String set(HttpServletRequest request, HttpServletResponse response) {
		
		Cookie c = new Cookie("userid", "홍길동");
		c.setMaxAge(3600); // 1시간
		response.addCookie(c);
	
		return "main";
	}
	
	// 서블릿 쿠키 코드
		@GetMapping("/get")
		public String get(HttpServletRequest request, HttpServletResponse response) {
			
			Cookie [] cookies = request.getCookies();
			for (Cookie c : cookies) {
				String name = c.getName();
				String value = c.getValue();
				logger.info("LOGGER:{}={}", name, value);
			}
		
			return "main";
		}

	 2) Spring Controller  처리

	   // spring 쿠키 얻기
		@GetMapping("/get2")
		public String get2(@CookieValue("userid") String s,
							@CookieValue("JSESSIONID") String s2) {
	
			logger.info("LOGGER:userid={}", s);
			logger.info("LOGGER:JSESSIONID={}", s2);
			return "main";
		}	


/////////////////////////////////////////////////////////////////

   Controller의 메서드가 String 리턴하면,
   이 String 는 뷰정보(jsp|thymeleaf)가 된다.


/////////////////////////////////////////////////////////////////
21. Controller에서 JSP에서 보여줄 데이터 저장 ( 모델 관리 )

        1) 이전 서블릿 처리
	   - scope에 저장했음.

             public void doGet(HttpServletRequest request, HttpServletResponse response){
                   
		   //데이터저장
		   request.setAttribute(key,value);
		   session.setAttribute(key,value);
		   application.setAttribute(key,value);

	           //데이터 보기
		   JSP를 forwared/redirect 해서 scope에 저장된 데이터 참조
		   이때 ${key} 이용.



	 2) Spring Controller  처리
	    - JSP에서 보여주는 데이터를 model 이라고 부름.
	    - scope에 저장함.

 ///////////////////////////////////////////////////
   * 자바의 3가지 변수
     1) 로컬변수: 
          생성~소멸: 메서드가 호출생성~ 메서드가 끝나면 제거됨.
	          임시적으로 사용되는 변수
          메모리: stack
	  특징: 반드시 명시적으로 초기화

     2) 인스턴스 변수(멤버 변수)
         생성~소멸: 객체생성(new) ~ 객체소멸되면 제거됨.
         메모리: heap
          특징: 자동초기화

     3) static 변수(클래스 변수)
         생성~소멸: 프로그램시작 ~ 프로그램 종료
         메모리: method area
           특징: 자동초기화
     예>
        public class Test{

	         int x;  // 인스턴스 변수(멤버 변수)
	 static int x2;  // static 변수(클래스 변수)
	  
	    public void method(int n){ // 로컬변수
		 
		 int x3;  // 로컬변수
		 s.o.p(x3); //에러발생
	    }

	}
	main(){
        	Test t = new Test(); // 인스턴스 변수가 생성됨
		//t= null;
		료// = new Test();
		t.method();
        }
  

   * 자바의 웹어플리케이션의 4가지 scope( 모델이 저장할때 적용되는 lifecycle 의미 )
    1) page scope
    2) request scope (기본)
        범위:  요청~응답
                        요청
	     웹브라우저 -----------------> Controller
	            <------------
		        응답
	클래스: HttpServletRequest

    3) session scope
        범위: 웹브라우저와 동일한 lifecycle 가짐
        클래스: HttpSession

    4) application scope
         범위: tomcat 서버와 동일한 lifecycle 가짐
        클래스: ServletContext

//////////////////////////////////////////////////////


         가. request scope에 모델 저장하는 방법

		@GetMapping("/set")
		public ModelAndView set() {  
		
			ModelAndView mav = new ModelAndView();
			// 모델 저장
			mav.addObject("userid", "홍길동" );
			mav.addObject("passwd", "1234" );
		
			// 뷰 저장 (JSP)
			mav.setViewName("main");
			return mav;
		}
		
		@GetMapping("/set6")
		public String set6(@ModelAttribute("xxx") ArrayList<LoginDTO> list) {  
		
			list.add(new LoginDTO("홍길동1", "1234"));
			list.add(new LoginDTO("홍길동2", "9999"));
			
			// 내부적으로 다음과 같다.
			// Model m = new Model();
			// m.addAttribute("loginDTOList", list)); //저장되는 key는 기본적으로 loginDTOList명으로 설정됨.
			// m.addAttribute("xxx", list)); //저장되는 key를 명시적으로 설정가능. @ModelAttribute("xxx") 이용
			
			return "main3";
		}
		
		
		@GetMapping("/set5")
		public String set5(@ModelAttribute("xxx")   LoginDTO dto) {  
		
			//m.addAttribute("dto", new LoginDTO("홍길동", "1234"));
			dto.setUserid("홍길동4");
			dto.setPasswd("12345");
			
			// 내부적으로 다음과 같다.
			// Model m = new Model();
			// m.addAttribute("loginDTO", dto)); //저장되는 key는 기본적으로 DTO명으로 설정됨.
			// m.addAttribute("xxx", dto)); //저장되는 key를 명시적으로 설정가능. @ModelAttribute("xxx") 이용
			
			return "main2";
		}
		
	//	@GetMapping("/set4")
	//	public String set4(Model m) {  
	//	
	//		m.addAttribute("dto", new LoginDTO("홍길동", "1234"));
	//	
	//		return "main2";
	//	}
		
		
		@GetMapping("/set3")
		public String set3(Map<String, String> m) {   // 내부적으로 객체생성됨.
		
			m.put("userid", "홍길동" );
			m.put("passwd", "1234" );
		
			return "main";
		}
		
		@GetMapping("/set2")
		public String set2(Model m) { // 내부적으로 객체생성됨.
		
			m.addAttribute("userid", "홍길동" );
			m.addAttribute("passwd", 1234 );
			
			return "main";
		}
		
		
		@GetMapping("/set1")
		public String set1(HttpServletRequest request) {
		
			request.setAttribute("userid", "홍길동" );
			request.setAttribute("passwd", 1234 );
			
			return "main";
		}


	 나. session scope에 모델 저장하는 방법

               a. 이전 Servlet 방식
	        
		  public void doGet(HttpServletRequest request, .. ){

		     HttpSession session = request.getSession();
		     session.setAttribute(key,value);
	    

               b. Spring 방식 
	       
	        - Model 생성방법 + key값을 세션에 저장한다는 설정추가 ( @SessionAttributes("xxx","key2") )
                - 모든 Controller에서 @SessionAttributes("xxx","key2") 반복적으로 설정해야 된다.

	 다. application scope에 모델 저장하는 방법


              a. 이전 Servlet 방식
	        
		  public void doGet(HttpServletRequest request, .. ){

		     ServletContext application = getServletContext();
		     application.setAttribute(key,value);
	     
	     b. Spring 방식 
	      
		      @Autowired
		      ServletContext application;

		      application.setAttribute(key,value);



22. Controller에서 메서드 리턴타입 종류


   웹브라우저 ---------->DispatcherServlet ----------> Controller
                                       <---------- a. 로직처리
				                      DB연동해서 가져온 데이터(Model)를 scope에 저장
				                   b. 뷰처리
						      jsp(View)업 알려주는 작업



    1) String 타입인 경우

     - 뷰 정보를 설정한 것임.
     - 모델은 파라미터로 설정함.

    2) ModelAndView 타입인 경우

     - 뷰 정보와 Model 정보를 각각 설정
     예>
       ModelAndView mav = new ModelAndView();
		// 모델 저장
		mav.addObject("userid", "홍길동" );
		mav.addObject("passwd", "1234" );
	
		// 뷰 저장 (JSP)
		mav.setViewName("main");


    3) Model를 리턴타입으로 지정

     
     가. DTO 타입

     예>

       @GetMapping("/zzz")   // zzz.jsp
       public @ModelAttribute("xxx")  LoginDTO a(){
       
         return new LoginDTO();
       }
   
   나. ArrayList 타입

     예>

       @GetMapping("/zzz") // zzz.jsp
       @ModelAttribute("xxx") 
       public ArrayList<LoginDTO> a(){
       
         return new ArrayList<LoginDTO>();
       }

   다. void 타입

     @GetMapping("/main3")  // main3.jsp
    public void  login3() {
		
     }


23.  JSON 통신

  - JSP가 필요 없음.

                       JSON
  웹 브라우저           ----------------------> Controller
  (js,jQuery(ajax)) <---------------------
   도구(Postman,          JSON
      Talend)           


  1) 요청시  From JSON to DTO(List) : @RequestBody

                      JSON
     웹 브라우저 ----------------------> Controller
   {userid:'홍길동',                      LoginDTO에 저장
    passwd:'1234'}                       String userid;
                                         String passwd;

   
   [{userid:'홍길동1',passwd:'1234'},     List<LoginDTO에> lilst
    {userid:'홍길동2',passwd:'1234'}]



  2) 응답  : From DTO(List) to JSON : @ResponseBody

    웹 브라우저  <--------------------- Controller
                    JSON

   {userid:'홍길동',                      LoginDTO에 저장
    passwd:'1234'}                       String userid;
                                         String passwd;

   
   [{userid:'홍길동1',passwd:'1234'},     List<LoginDTO에> lilst
    {userid:'홍길동2',passwd:'1234'}]


    나중에는 다음과 같다.

                           JSON
    웹브랑우저       --------------------------------> Controller
    (React.js)   <-------------------------------
                           JSON



24. redirect 와 forward

   1) 이전 Servlet 코드

       public void doGet(HttpServletRequest request, HttpServletResponse response ){

        //리다이렉트 방식
	response.sendRedirect("타겟");

	//forward 방식
	request.getRequestDispatcher("타겟").forward(request, response);


    2) Spring 방식

     @GetMapping("/xxx") 
    public String  login3() 

    }

    @GetMapping("/main")  
    public String  login() {

	//기본
	return "xxx"; //xxx.jsp

	//리다이렉트 방식	
	return "redirect:xxx"; // xxx.jsp아니고 요청맵핑값이다. 즉 @GetMapping("/xxx")으로 리다이렉트 요청함
	                          URL이 변경됨. request scope에 저장된 데이터는 jsp에서 참조 불가.

	//forward 방식
        return "forward:xxx"; // xxx.jsp아니고 요청맵핑값이다.  즉 @GetMapping("/xxx")으로 forward 요청함
	                          URL이 변경 안됨. request scope에 저장된 데이터는 jsp에서 참조 가능.

     }

 
 25.  redirect 의 flash scope

   -  request scope <  flash scope  < session scope

     flash scope 는 redirect 했을 때 한 번만 사용가능한 방법이다.

   - RedirectAttributes 모델과 m.addFlashAttribute("userid", "이순신") 이용

    예>
      @GetMapping("/redirect-flash")
	public String aaa2(RedirectAttributes m) {
		logger.info("LOGGER:{}", "redirect-flash 호출");
		
		m.addFlashAttribute("userid", "이순신");
		
		return "redirect:xxx";
	}

 26. PRG 패턴 ( Post-Redirect-Get 패턴 )

 1)개념
   post 요청에 대해서 GET 방식의 웹페이지로 리다이렉트 요청하는 패턴.
   즉 post 요청으로 시작해서 GET 요청으로 종료하라는 의미.

   PRG 패턴을 적용하지 않으면 다음과 같은 문제가 발생됨
   가. 새로고침하면 동일한 요청이 연속적으로 보내지는 이슈가 발생됨. ( 멱등 이슈 )
   나. URL 복사해서 사용하면 405 에러가 발생 이슈
   
   예>
     @GetMapping("/main")
	public String list() {
		return "main";
	}
	
	
	@PostMapping("/write")
	public String write(@RequestParam("userid") String id, 
			            @RequestParam("passwd")  String pw,
			            @RequestParam("age")  Long age) {

		
		logger.info("LOGGER:{},{},{}", id, pw, age);
		return "redirect:success";  // success.jsp
	}
	
	
	@GetMapping("/success")
	public String success() {
		return "success";
	}


 27. 파일업로드

   - 기존 Servlet 또는 Spring Framework에서 파일 업로드를 구현할려면
     의존성 추가 필요함.
     하지만 SpringBoot에서는 의존성 파일이 내장되어 있음.

   - 구현
    1) jsp 파일 작업
https://commons.apache.org/proper/commons-fileupload/
      - 반드시 method와 enctype를 다음과 같이 설정해야 됨.
        method="post"
        enctype="multipart/form-data"

    <form method="POST" enctype="multipart/form-data" action="">
         파일: <input type="file" name="theFile"> <br>
         내용: <input type="text" name="theText"> <br>

   2) DTO 작성


	     
	public class UploadDTO {

		MultipartFile theFile;
		String theText;

   3) Controller 작성
      @PostMapping("/upload")
	public String upload(UploadDTO dto) {
		
		
		MultipartFile theFile = dto.getTheFile();
		String theText = dto.getTheText();
		
		//byte[] byte_arr = theFile.getBytes();
		String contentType =theFile.getContentType();
		String name = theFile.getName();
		String originalFilename
		      = theFile.getOriginalFilename();
		long size = theFile.getSize();
		
		logger.info("LOGGER:contentType: {}", contentType);
		logger.info("LOGGER:name: {}", name);
		logger.info("LOGGER:originalFilename: {}", originalFilename);
		logger.info("LOGGER:size: {}", size);
		
		// 저장할 경로 설정
		File f = new File("c:\\upload", originalFilename);
		
		// 파일 저장
		try {
			theFile.transferTo(f);
		} catch (IllegalStateException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return "uploadInfo";  //나중에 PRG 패턴으로 변경
	}
}
   
     4) JSP에서 업로드된 파일 정보 출력 

       
	 <h1>uploadInfo.jsp</h1>
	 업로드 파일크기:${uploadDTO.theFile.size} <br>
	 업로드 파일명:${uploadDTO.theFile.originalFilename}

      5) 파일업로드 관련 설정 
        - application.properties 이용

	# 파일업로드 설정
	spring.servlet.multipart.enabled=true
	#  하나의 파일크기, 기본은 1MB.
	spring.servlet.multipart.max-file-size=3MB  
	# 한번 요청 최대 크기, 기본은 10MB.
	spring.servlet.multipart.max-request-size=15MB


 28. 인터셉터 1-  Filter 적용

    1) 이전 Servlet 코드
    
      웹브라우저 ------>   필터    ---> 서블릿

      a. public class MyFilter implments Filter{
                
           	public void doFilter(ServletRequest request, 
			ServletResponse response, 
			FilterChain chain) throws IOException, ServletException {
	
		//서블릿 요청전 코드 작업 ( 요청 필터 )
		System.out.println("MyFilter.요청 필터");
		
		chain.doFilter(request, response);
		
		//서블릿 응답후 코드 작업 ( 응답 필터 )
		System.out.println("MyFilter.응답 필터");
		
	}

         }
     
      b. web.xml 등록

        <filter>
	    <filter-name>MyFilter2</filter-name>
	    <filter-class>com.filter.MyFilter2</filter-class>
	  </filter>
	  <filter-mapping>
	    <filter-name>MyFilter2</filter-name>
	    <url-pattern>/*</url-pattern>
	  </filter-mapping>
  

    2) Spring 코드

        웹브라우저 ------>   필터    ---> 서블릿(DispatcherServlet) ------> Controller

         a. public class MyFilter implments Filter{
                
           	public void doFilter(ServletRequest request, 
			ServletResponse response, 
			FilterChain chain) throws IOException, ServletException {
	
		//서블릿 요청전 코드 작업 ( 요청 필터 )
		System.out.println("MyFilter.요청 필터");
		
		chain.doFilter(request, response);
		
		//서블릿 응답후 코드 작업 ( 응답 필터 )
		System.out.println("MyFilter.응답 필터");
		
	}

         }
	 

	 b. web.xml 대신에 설정정보를 저장할 새로운 빈을 작성
https://docs.spring.io/spring-boot/docs/3.2.12/reference/html/web.html#web.servlet.spring-mvc.error-handling.error-pages-without-spring-mvc
	   - // MyFilter 등록
		@Configuration
		public class WebConfig implements WebMvcConfigurer {

			// 직접 등록
			@Bean
			public FilterRegistrationBean<MyFilter>  myFilter(){
				FilterRegistrationBean<MyFilter> filter = 
						new FilterRegistrationBean<MyFilter>(new MyFilter());
				//filter.serOrder(1);
				filter.addUrlPatterns("/*");  // web.xml의 <url-pattern>/*</url-pattern>
				return filter;
			}
			
		}



28. 인터셉터 2-  HandlerInterceptor 적용



   웹브라우저 ------>   필터    ---> 서블릿(DispatcherServlet) --> 인터셉터(preHandle)     --> Controller
                                                       <-- 인터셉터(postHandle)    <--
									       
				|
				|
	 <--	인터셉터	<---   jsp
               (afterCompletion)

     구현

     a.  implments HandlerInterceptor
	       @Component
	public class MyHandlerInterceptor implements HandlerInterceptor {
		private Logger logger = LoggerFactory.getLogger(getClass());
		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
				throws Exception {
			logger.info("LOGGER: {}", "preHandle 호출");
			return true;
		}

		@Override
		public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
				ModelAndView modelAndView) throws Exception {

			logger.info("LOGGER: {}", "postHandle 호출");
		}

		@Override
		public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
				throws Exception {

			logger.info("LOGGER: {}", "afterCompletion 호출");
		}

		
	}

     b.  설정정보를 저장할 새로운 빈을 작성

       // Interceptor 등록
	@Configuration
	public class WebConfig implements WebMvcConfigurer {

		@Autowired
		MyHandlerInterceptor xxx;
		
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			
			registry.addInterceptor(xxx)
				.addPathPatterns("/main","/xxx", "/yyy*", "/zzz/**/kkk");
			
			
		}

		
	}


29. 예외처리
https://docs.spring.io/spring-boot/docs/3.1.12/reference/html/web.html#web.servlet.spring-mvc.error-handling

 1) 개념
   - MyBatis 사용할 때 발생되는 예외는 모두 RuntimeException 계열이다.
    따라서 DAO 또는 Service에서 예외가 발생되면 자동으로 Controller에게 예외가 위임된다.
    결국 Controller에서 예외처리를 해야 된다.
    선언적 방법(@ExceptionHandler, @ControllerAdvice)으로 처리한다.

    현재는 예외가 발생되었을 때 WhiteLabel Error page를 보여준다. 이 방법이 SpringBoot에서 제공하는 기본 에러페이지임.
    그런데 이 방법을 커스터마이징해서 개발자가 만든 에러페이지를 보여주자.

  웹브라우저 ---------------> Controller <--------> Service <----------> DAO <--------> MySQL

 
 2) 방법 2가지

  가. 로컬
    - 특정 Controller만 예외처리 가능

   예>
      @Controller
      public class TestController {

      ...
        //로컬 예외처리
	@ExceptionHandler(value = { IllegalArgumentException.class, NullPointerException.class } )
	public String errorPage(Exception e, Model m) {
		logger.info("LOGGER:{}", e.getMessage());
		
		m.addAttribute("errorMessage", e.getMessage());
		return "errorPage";  // errorPage.jsp
	}




  나. 전역
   - 모든 Controller 예외처리 가능

   예> 
     // @ControllerAdvice 
	//@ControllerAdvice(basePackages = {"com.exam.controller"})
	@ControllerAdvice(assignableTypes = TestController.class)
	public class GlobalExceptionHandler {
		private Logger logger = LoggerFactory.getLogger(getClass());
		
		   //전역 예외처리
			@ExceptionHandler(value = { IllegalArgumentException.class,
					NullPointerException.class } )
			public String errorPage(Exception e, Model m) {
				logger.info("LOGGER:{}", e.getMessage());
				
				m.addAttribute("errorMessage", e.getMessage());
				return "errorPage";  // errorPage.jsp
			}
			
	}


30. 국제화 ( I18N: Internationalization )

  1)개념
    - 다국어 처리
    예> 한국어, 영어, ...

  2) 현재 Locale 정보 확인
    
    //현재 로케일 정보
    // 요청헤더값 중에서 accept-language: ko-kr, ko  값이고 이것이 기본 Locale 임.
    Locale locale = LocaleContextHolder.getLocale();
    logger.info("LOGGER: 현재 Locale : {}", locale );

  
  3) SpringBoot에서 특정언어(Locale) 선택하는 방법

    가. AcceptHeaderLocaleResolver
       - 기본 LocaleResolver 임.
       - accept-language:ko 헤더정보로 로케일(언어및국가)정보를 얻음.
       - accept-language:ko 헤더정보를 서버에 전달한다.

    나. CookieLocaleResolver
       - 쿠키정보를 이용해서 로케일(언어및국가)정보를 얻음.
       - setLocale(request, response, locale) 이용해서 Locale 변경 가능.
       -  accept-language=ko 쿠키를 서버에 전달한다.

    다. SessionLocaleResolver
       - 세션정보를 이용해서 로케일(언어및국가)정보를 얻고 세션에 저장.
       - 로케일정보는 querystring으로 서버에 전달한다.
       예> ?lang=ko
       - setLocale(request, response, locale) 이용해서 Locale 변경 가능.

     
   4) 구현방법

    가. 리소스 번들 파일 작성

       기본이 되는 messages.properties 작성하고
       추가로 각 언어별 리소스번들파일 을 작성하고 encoding을 UTF-8로 변경한다.

       문법: messages_국가별언어코드.properties

       예> messages.properties
          messages_ko.properties
	  messages_ja.properties
	  messages_en.properties

       src/main/resource
                 
		   messages
		         messages.properties
			 messages_ko.properties
			 messages_en.properties
		      
                   application.properties


    나. 리소스번들파일 등록
    https://docs.spring.io/spring-boot/docs/3.1.12/reference/html/features.html#features.internationalization
      - application.properties 에 등록

      # 리소스 번들 파일 등록 ( 파일명만 지정, 만약 폴더가 있으면 폴더도 지정해야 됨 )
      spring.messages.basename=messages/message


      # 일치하는 Locale이 없는 경우
      spring.messages.fallback-to-system-locale=true|false ( 기본 true )
     
      true:    기본 리소스 번들 파일인 memssage.propeties를 적용하지 않고 제어판의 국가별 설정 정보로 적용됨.
      false:   제어판의 국가별 설정 정보가 아닌  기본 리소스 번들 파일인 memssage.propeties 적용됨.


    다. 리소스 번들 파일 참조
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/MessageSource.html
	
	* 계층구조

			  MessageSource ( 인터페이스 )
			    |
			    |
ResourceBundleMessageSource   ReloadableResourceBundleMessageSource( *.properties 파일변경 사항을 자동체크해서 반영)


       a. Controller에서 참조

	   @Autowired
        -   MessageSource messageSource;

	-   messageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);


       b. JSP에서 참조

         - taglib 필요

	 <%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>


	 message:<spring:message code="greeting" text="기본 메시지" /> 


   5) SessionLocaleResolver 구현1 - 명시적으로(수동으로) Controller에서 setLocale() 이용해서 로케일 변경

   주의할점: SessionLocaleResolver 생성시 반드시 메서드명은 localeResolver() 사용해야 된다.


     가. 리소스번들 작성 및 등록

       -  src/main/resource
                 
		   messages
		         messages.properties
			 messages_ko.properties
			 messages_en.properties
		      
       - application.properties 등록

       spring.messages.basename=messages/message

     
     나.  SessionLocaleResolver 생성

      - 기본인 AcceptHeaderLocaleResolver 대신에 SessionLocaleResolver를 사용하겠다는 의미.

       @Configuration
	public class WebConfig implements WebMvcConfigurer {


		//SessionLocaleResolver
		@Bean
		public SessionLocaleResolver localeResolver() {  // 메서드는 반드시 localeResolver() 메서드만 가능하다.
			SessionLocaleResolver localeResolver =
				⅓new SessionLocaleResolver();
			
			//기본 locale 설정
			localeResolver.setDefaultLocale(new Locale("ko"));
			return localeResolver;
		}
	}

     다. Controller에서 SessionLocaleResolver 참조해서 setLocale(Locale) 이용해서 Locale 변경.

     @Autowired
	SessionLocaleResolver sessionLocaleResolver;
	
	// http://localhost:8090/app/main?lang=en|ja|ko
	@GetMapping("/main")
	public String main(
			HttpServletRequest request,
				       HttpServletResponse response,
				       @RequestParam("lang") String lang
				       
			           ) {
		logger.info("LOGGER: {}, {}", "main 호출", lang);
				
		// 수정된 locale 설정
		//setLocale(request, response, locale) 이용해서 Locale 변경 가능.
		sessionLocaleResolver.setLocale(request, response, new Locale(lang));
		
		//
		return "main";
	}


   5) SessionLocaleResolver 구현2 - 자동으로 Locale 변경 <== LocaleChangeInterceptor 이용

       가. 리소스번들 작성 및 등록

       -  src/main/resource
                 
		   messages
		         messages.properties
			 messages_ko.properties
			 messages_en.properties
		      
       - application.properties 등록

       spring.messages.basename=messages/message

     
     나.  SessionLocaleResolver 생성

      - 기본인 AcceptHeaderLocaleResolver 대신에 SessionLocaleResolver를 사용하겠다는 의미.

       @Configuration
	public class WebConfig implements WebMvcConfigurer {


		//SessionLocaleResolver
		@Bean
		public SessionLocaleResolver localeResolver() {  // 메서드는 반드시 localeResolver() 메서드만 가능하다.
			SessionLocaleResolver localeResolver =
				⅓new SessionLocaleResolver();
			
			//기본 locale 설정
			localeResolver.setDefaultLocale(new Locale("ko"));
			return localeResolver;
		}
	}


     다. LocaleChangeInterceptor 생성하고 등록하기

         // LocalChangeInterceptor 생성
	@Bean
	public LocaleChangeInterceptor localeChangeInterceptor() {
		LocaleChangeInterceptor xxx = new LocaleChangeInterceptor();
		// ?lang=en|ja|ko  또는 ?locale=en|ja|ko , ?xxx=en|ja|ko
		// (default parameter name: "locale").
		xxx.setParamName("lang");
		return xxx;
	}
	
	// LocalChangeInterceptor 등록
	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		 registry.addInterceptor(localeChangeInterceptor());
	}


31. jQuery 와 bootstrap 외부 라이브러리 사용방법


   1) 이전 방식 (수업때 배웠던 방식)
     
     jQuery: 
        
	   <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
     
     bootstrap:
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
          <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>



   2) Spring 최신 방식
     - 이전 방식 사용 가능하지만 경로가 변경되거나 네트워크이 불안정하면 이슈가 발생될 수 있다.
       해결: webjars 

     - webjars 사용 방법은 의존성 설정해서 로컬에 라이브러리 설치하는 방식으로 사용하는 방법이다.

     - 구현

      가. 의존성 설정
       
        jQuery 의존성

           <!-- https://mvnrepository.com/artifact/org.webjars/jquery -->
	<dependency>
	    <groupId>org.webjars</groupId>
	    <artifactId>jquery</artifactId>
	    <version>3.7.1</version>
	</dependency>

        bootstrap 의존성

	<!-- https://mvnrepository.com/artifact/org.webjars/bootstrap -->
	<dependency>
	    <groupId>org.webjars</groupId>
	    <artifactId>bootstrap</artifactId>
	    <version>5.3.3</version>
	</dependency>


      나. jsp 에서 사용

        webjar의 실제 경로는 다음과 같다. 하지만 실제 사용할 때는 webjars 경로부터 사용한다. ( /META-INF/resources/ 지정 안함)
	 
	  jquery:

	    /META-INF/resources/webjars/jquery/3.7.1/jquery.min.js

          bootstrap:

	     /META-INF/resources/webjars/bootstrap/5.3.3/css/bootstrap.min.css
	     /META-INF/resources/webjars/bootstrap/5.3.3/js/bootstrap.bundle.min.js

	
	예> 
	<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>

	 <link rel="stylesheet" href="webjars/bootstrap/5.3.3/css/bootstrap.min.css" >
	 <script src="webjars/bootstrap/5.3.3/js/bootstrap.bundle.min.js"></script>

	<script src="webjars/jquery/3.7.1/jquery.min.js"></script>
	<script>
	 
	  $(document).ready(function(){
		  alert("alert");
	  });
	  
	</script>
	</head>
	<body>
	 <h1>main.jsp</h1>
	 <button type="button" class="btn btn-primary">Primary</button>



32. 사용자 입력 유효성 검사

   1)개념
   - 사용자 입력화면에서 입력된 데이터의 유효성 검사 방법.
   예> 필수입력, 길이, 특수문자|대문자|소문자포함여부,..., 이메일(@ 지정여부)........

   2)구현방식
    가. html 속성 이용
      예> required 속성
         type="email"
       <form action="target.html" method="get">
		아이디: <input type="text" name="userid" required> <br>
		비밀번호: <input type="password" name="passwd" maxlength="4"> <br>
		email: <input type="email" name="passwd"> <br>
		<input type="submit" value="로그인">
	</form>

    나. JS 및 jQuery 이용
      
       예> event.preventDefault()  

        $("#myForm").on("submit", function(){
              // 자동 submit 방지
              event.preventDefault();
          });

    다. Spring의 유효성 체크1 - @Valid 어노테이션 ( jakarta.validation 패키지 이용 )

       a. 의존성 추가
          	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>


       b. 사용자 입력 데이터를 저장할 DTO 생성 및 유효성 관련 어노테이션 설정
https://docs.spring.io/spring-framework/reference/6.1/core/validation/beanvalidation.html

         public class MemberDTO { // Command object ( form backing object)
	@NotNull(message = "userid 필수")  // null 허용 안함
//	@NotEmpty // null 및 공백문자 허용 안함.
//	@NotBlank // null 및 공백문자 및 space 허용 안함.
	String userid;
	
	@NotNull (message = "passwd 필수")  
	String passwd;
	
	@Size(max = 4, message = "최대 4글자")
	String username;
	
	String phone;
	
	@NotNull (message = "targetDate 필수")
	@FutureOrPresent(message = "현재 또는 미래날짜만 가능")               //@Past
	LocalDate targetDate;


       c. Controller 작업

	- 반드시 GET 과 POST 요청에서 DTO를 모델로 사용해야 된다. (************)
	- 반드시 GET 과 POST 의 요청맵핑값이 같아야 된다.

        
	  가. GET 방식 요청의 화면 보기
                 @GetMapping("/member")
		public String memberForm(Model m) {
			
			//DTO를 Model에 저장 필수
			MemberDTO dto = new MemberDTO();
			m.addAttribute("xxx", dto);
			
			return "memberForm";
		}

	  나. POST 방식 요청의 실제 요청처리

            @PostMapping("/member")
	public String member(@Valid  @ModelAttribute("xxx") MemberDTO dto,
			              BindingResult result) {
		
		if(result.hasErrors()) {
			return "memberForm";
		}
		
		// 성공시 코드 작성
		
		return "main";
	}

       d. memberForm.jsp
       https://docs.spring.io/spring-framework/reference/web/webmvc-view/mvc-jsp.html
        - Spring의 form 태그라이브러리 필요.
          <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

	  <form:form modelAttribute="xxx" method="post">
	   <table>
		<tr>
			<td>userid:</td>
			<td><form:input type="text" path="userid"/></td>
			<td><form:errors  path="userid"/></td>
		</tr>
		<tr>
			<td>passwd:</td>
			<td><form:input type="text" path="passwd"/></td>
			<td><form:errors  path="passwd"/></td>
		</tr>
		<tr>


     다. Spring의 유효성 체크2 - @Validated 어노테이션 (org.springframework.validation.annotation.Validated 패키지)

       a. 의존성 추가
          	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>

	
       b. 사용자 입력 데이터를 저장할 DTO 생성 ( DTO에서 @NotNull 어노테이션 사용 안함. Controller에서 지정함 )

         public class MemberDTO {


		String userid;
		String passwd;
		String username;
		String phone;
		LocalDate targetDate;



      c. Controller 작업
	
	 - @Validated 클래스 레벨에 지정
	 - MembderDTO 무관


          가. GET 방식 요청의 화면 보기
              @GetMapping("/member")
		public String memberForm() {
			return "memberForm";
		}


	  나. POST 방식 요청의 실제 요청처리

	     @PostMapping("/member")
	    public String member(@NotBlank(message = "userid 필수")
	                     @RequestParam String userid,
	                     
	                     @RequestParam String passwd,
	                     
	                     @Size(max = 4, message = "최대 4글자")
	                     @RequestParam String username,
	                     
	                     @RequestParam String phone,
	                     
	                     @NotNull (message = "targetDate 필수")
	                 	 @FutureOrPresent(message = "현재 또는 미래날짜만 가능")
	                     @RequestParam LocalDate targetDate
				         ) {
	
    d. memberForm.jsp

      - MemberDTO 와 무관하기 하기 때문에 일반 html 구현함.
      h1>회원가입 화면</h1>
	 <form  method="post" action="member">
		<table>
			<tr>
				<td>userid:</td>
				<td><input type="text" name="userid"/></td>
			</tr>
			<tr>
				<td>passwd:</td>
				<td><input type="text" name="passwd"/></td>
			</tr>
			<tr>
				<td>username:</td>
				<td><input type="text" name="username"/></td>
			</tr>
			<tr>
				<td>phone:</td>
				<td><input type="text" name="phone"/></td>
			</tr>
			<tr>
				<td>targetDate:</td>
				<td><input type="date" name="targetDate"/></td>
			</tr>
			<tr>
				<td colspan="2">
					<input type="submit" value="회원가입"/>
				</td>
			</tr>
		</table>
	</form>
 

     e.  에러발생시 처리는 전역 예외처리 방식이용 (@ControllerAdvice )

       - @Validated 로 설정한 유효성체크는 에러발생시 ConstraintViolationException 예외가 발생되어
         Whitelabel Error page가 보여진다.

	 이 페이지를 사용자가 원하는 페이지로 보여주는 작업을 하자.

        @ControllerAdvice
	public class GlobalExceptionHandler {
		private Logger logger = LoggerFactory.getLogger(getClass());
		
		   //전역 예외처리
			@ExceptionHandler(value = { IllegalArgumentException.class,
					ConstraintViolationException.class } )
			public String errorPage(Exception e, RedirectAttributes m) {
				logger.info("LOGGER:{}", e.getMessage());
				
				m.addFlashAttribute("errorMessage", e.getMessage());
				return "redirect:member";  // errorPage.jsp
			}
			
	}

// 화면이 있는 StringBoot 문법임. ( SOAP 방식 , 2차 프로젝트 )


 
   웹브라우저 ---------------> Controller <----> Service <--->DAO
                               |
			       |
          <--------------    JSP(Thymeleaf)


// 앞으로 배울 StringBoot 문법임. ( REST 방식, 최종 프로젝트 )

                       JSON
  도구         ---------------> Controller 
(웹브라우저,      <---------------
 (reactjs)             JSON
 모바일,       
 TV,
 ..)

////////////////////////////////////////////////////////////////////////////////////////

SpringBoot 버전의 ShopMiniMall

 1. boot10_ShopMiniMall 프로젝트 생성

 2. 의존성 설정

   - pom.xml 에 추가
   		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>		
<dependency>
	    <groupId>org.mybatis.spring.boot</groupId>
	    <artifactId>mybatis-spring-boot-starter</artifactId>
	    <version>3.0.3</version>
</dependency>
        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
	    <groupId>mysql</groupId>
	    <artifactId>mysql-connector-java</artifactId>
	    <version>8.0.33</version>
</dependency>
 <dependency>
	  <groupId>org.apache.tomcat.embed</groupId>
	  <artifactId>tomcat-embed-jasper</artifactId>
	  <scope>provided</scope>
</dependency>
<dependency>
	  <groupId>jakarta.servlet.jsp.jstl</groupId>
	  <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
</dependency>
<dependency>
	  <groupId>org.glassfish.web</groupId>
	  <artifactId>jakarta.servlet.jsp.jstl</artifactId>
</dependency>	
 <dependency>
    <groupId>org.webjars</groupId>
    <artifactId>jquery</artifactId>
    <version>3.7.1</version>
</dependency>
 
 <dependency>
    <groupId>org.webjars</groupId>
    <artifactId>bootstrap</artifactId>
    <version>5.3.3</version>
</dependency>

   3. application.properties 설정

      가. 로깅
      나. tomcat port 변경
         context명 추가

      다. jsp의 prefix/suffix 설정
      라. MySQL 연동위한 4가지 정보 설정
      마. 요청시 /aa/** 위한 패턴 등록

      바. LocatDate 사용시 날짜 포맷 지정. 4자리년도-2자리월-2자일 예> 2025-05-23

		# 로그레벨 수정
	logging.level.root=info

	#logging.level.org.springframework=info
	logging.level.com.exam=info


	# tomcat port 번호 변경
	server.port=8090

	# context명 변경
	server.servlet.context-path=/shop


	# JSP용 prefix 와 suffix 설정
	spring.mvc.view.prefix=/WEB-INF/views/
	spring.mvc.view.suffix=.jsp


	# DB 연동
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
	spring.datasource.url=jdbc:mysql://localhost:3306/shop
	spring.datasource.username=shop
	spring.datasource.password=shop
	# DeptMapper 등록
	mybatis.mapper-locations=com/exam/config/*Mapper.xml
	# DTO 별칭
	mybatis.type-aliases-package=com.exam.dto

	#  SQL의 컬럼명: target_date   ,  DTO 변수명: targetDate  인 경우
	#  별칭 또는 resultMap 으로 명시적으로 설정해서 사용했음.
	#  이 작업을 자동으로 할 수 있다.
	mybatis.configuration.map-underscore-to-camel-case=true

	# // /** 설정시 적용
	spring.mvc.pathmatch.matching-strategy=ant-path-matcher

	# LocatDate 사용시 날짜 포맷 지정. 4자리년도-2자리월-2자일 예> 2025-05-23
	spring.mvc.format.date=yyyy-MM-dd

   

   4. com.exam.dto.GoodsDTO 작성
       
       @Alias("GoodsDTO")
	public class GoodsDTO {
		
		String gCode;
		String gCategory;
		String gName;
		String gContent;
		int gPrice;
		String gImage;


   5. 이전 MainServlet에서 했던 작업을 대신할 MainController 작성하기 위해서
      GoodsService 인터페이스와 GoodsServiceImpl 작성

        public interface GoodsService {

		public List<GoodsDTO> goodsList(String gCategory);
		
	}
	@Service
	public class GoodsServiceImpl implements GoodsService{

		GoodsMapper mapper;
		
		public GoodsServiceImpl(GoodsMapper mapper) {
			this.mapper = mapper;
		}


		@Override
		public List<GoodsDTO> goodsList(String gCategory) {
			return mapper.goodsList(gCategory);
		}

	}


    6. com.exam.mapper.GoodsMapper.java 와 
       com.exam.mapper.GoodsMapper.xml 작성
       ( 기존방식의 DAO 사용 안함 )

       @Mapper
	public interface GoodsMapper {

		public List<GoodsDTO> goodsList(String gCategory);
		
	}

       <mapper namespace="com.exam.mapper.GoodsMapper">
	 <select id="goodsList" resultType="GoodsDTO" 
	 parameterType="string">
	 	 
	 	  select gCode, 
	 	        gCategory,
	 	        gName,
	 	        gContent,
	 	        gPrice,
	 	        gImage
	 	  from goods
	 	  where gCategory = #{gCategory}
	 
	 </select>

 
      7.  MainController.java 코드 구현

		 @Controller
	public class MainController {

		GoodsService service;
		
		public MainController(GoodsService service) {
			this.service = service;
		}


		@GetMapping("/main") //main.jsp
		@ModelAttribute("goodsList")
		public List<GoodsDTO> main(@RequestParam(required = false, defaultValue = "top")
				    String gCategory) {
			
			// JSP에서 보여줄 데이터고 모델에 저장해야 된다.
			List<GoodsDTO> list = service.goodsList(gCategory);
			
			return list;
		}
		
	}

     8. main.jsp 작성

       - 웹 어플리케이션 디렉터리 구조를 작성

         src/main/resources
             /META-INF/resources/WEB-INF/views/sayHello.jsp


       - jQuery와 BootStrap 를 webjar 링크로 변경하자.

	  <link rel="stylesheet" href="webjars/bootstrap/5.3.3/css/bootstrap.min.css" >
	 <script src="webjars/bootstrap/5.3.3/js/bootstrap.bundle.min.js"></script>

	<script src="webjars/jquery/3.7.1/jquery.min.js"></script>


     9. image 설정

        src/main/resource
	  
	               static
		           images 

///////////////////////////////////////////////////////////////////////////////////////////////////
 
  10.회원가입

    
    가. 회원가입화면보기 
      이전 MemberUIServlet.java(/signup) 에 해당되는 MemberController.java 작성

       //회원가입 화면보기
	@GetMapping("/signup")
	public String signupForm() {
		return "memberForm";
	}
  
    나. id 중복체크

       이전 MemberIdCheckServlet.java (/idCheck) 에 해당되는 MemberController.java 작성

       
	//id 중복체크
	@GetMapping("/idCheck")
	@ResponseBody
	public String idCheck(@RequestParam String userid) {
		
		String mesg = "아이디 사용 가능";
		
		MemberDTO dto = memberService.idCheck(userid);
		
		if(dto!=null) {
			mesg = "아이디 중복";
		}
		
		return mesg;
	}

	MemberDTO.java 와 MemberMapper.java, MemberMapper.xml 작성하기


     다. 회원가입 + @Valiated 유효성 체크

        이전 MemberAddServlet.java (/memberAdd) 에 해당되는 MemberController.java 작성

	 
	  @Controller
	  @Validated
	  public class MemberController{

	     //회원가입
	@PostMapping("/signup")
	public String signup(@RequestParam String userid,
			             
			             @Size(min = 2, message = "최소 2글자")
			             @RequestParam String passwd,
			             
			             @NotBlank(message = "username 필수")
			             @RequestParam String username,

	- 에러 발생시 예외처리 담당. 

	  @ControllerAdvice
	public class GlobalExceptionHandler {
		private Logger logger = LoggerFactory.getLogger(getClass());
		
		   //전역 예외처리
			@ExceptionHandler(value = { IllegalArgumentException.class,
					ConstraintViolationException.class } )
			public String errorPage(Exception e, RedirectAttributes m) {
				logger.info("LOGGER:{}", e.getMessage());
				
				m.addFlashAttribute("errorMessage", e.getMessage());
				return "redirect:signup";  // /signup
			}
			
	}


      라. 회원가입

 ########################################################################################        

  11. 로그인 및 로그아웃

    1) 로그인 화면 보기
   
      이전 LoginUIServlet.java (/loginForm) 에 해당되는 LoginController.java 작성

       @Controller
public class LoginController {



	@GetMapping("/loginForm") 
	public String main() {
		
		return "loginForm";
	}


     2) 로그인 + 유효성 체크 ( @Valiated 이용 )

     이전 LoginServlet.java (/login) 에 해당되는 LoginController.java 작성

        @Controller
	@SessionAttributes(value = {"login"}) // Model에 "login" 키를 사용하면 HttpSession에 저장됨.
	public class LoginController {

	  
	@PostMapping("/login")
	public String login(@RequestParam Map<String, String> map,  Model m) {
		
		MemberDTO dto = memberService.login(map);
		
		if(dto!=null) {
		  //정상 로그인	
		  m.addAttribute("login", dto);
		  return "redirect:main";
		}
		
		//실패하면
		m.addAttribute("errorMessage", "아이디와 비번 다시 확인하시오");
		return "loginForm";  // loginForm.jsp
		
	}

      3) 로그아웃

      - 이전 LogoutServlet.java (/logout) 에 해당되는 LoginController.java 작성
      - 로그인이후의 작업이기 때문에 로그인 여부를 확인해야 된다.
	이 작업을 HandlerInterceptor 이용해서 할 생각임.


	@GetMapping("/logout")
	public String logout(SessionStatus status) {
		
		// @SessionAttributes 를 사용한 세션을 cleanup 시킴
		status.setComplete();
		
		return "redirect:main";
	}
	
////////////////////////////////////////////////////////////////////////////

 12. MyPage

   이전 MyPageServlet.java (/mypage) 에 해당되는 MemberController.java 작성


      @Controller
@Validated
@SessionAttributes("login")
public class MemberController {

	
	MemberService memberService;
	
	public MemberController(MemberService memberService) {
		this.memberService = memberService;
	}
	
	// mypage
	@GetMapping("/mypage")
	public String mypage(Model m) {
		
		MemberDTO dto =
				(MemberDTO)m.getAttribute("login");
		
		String userid = dto.getUserid();
		MemberDTO mypageDTO = memberService.mypage(userid);
		m.addAttribute("login", mypageDTO);
		
		return "mypage";
	}

////////////////////////////////////////////////////////////////////////////

 13. 상품 자세히 보기

   이전 GoodsRetrieveServlet.java (/goodsRetrieve) 에 해당되는 GoodsController.java 작성

   GoodService.java /GoodsServiceImpl.java  GoodsMapper.java GoodsMapper.xml 


 
14. 장바구니 저장 및 유효성 체크 (gAmount 최소1 최대10, @Validated )

   이전 CartAddServlet.java (/cartAdd) 에 해당되는  CartController.java 작성

   CartDTO.java

   CartService.java /CartServiceImpl.java  CartMapper.java CartMapper.xml 




15. 장바구니 목록보기

    이전 CartListServlet.java (/cartList) 에 해당되는  CartController.java 작성

    CartService.java /CartServiceImpl.java  CartMapper.java CartMapper.xml 


 16. 장바구니 개별 삭제

    이전 CartDeleteServlet.java (/cartDelete) 에 해당되는  CartController.java 작성

    CartService.java /CartServiceImpl.java  CartMapper.java CartMapper.xml 

  
 17. 장바구니 전체 삭제

   이전 CartDeleteAllServlet.java (/cartDeleteAll) 에 해당되는  CartController.java 작성

    CartService.java /CartServiceImpl.java  CartMapper.java CartMapper.xml 


 18. 개별주문 

    이전 OrderConfirmServlet.java (/orderConfirm) 에 해당되는  OrderController.java 작성

    OrderDTO.java

   OrderService.java / OrderServiceImpl.java  OrderMapper.java OrderMapper.xml 
